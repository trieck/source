///////////////////////////////////////////////////////////////////////////////// ODBCUTIL.CPP : ODBC utility classes//#include "common.h"#include "odbcutil.h"#include "resource.h"Environment Connection::E;	// shared by all instances#define DEFAULT_LOGIN_TIMEOUT	15// helper functionsstatic bool getDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle,                       SQLSMALLINT RecNumber, SQLCHAR * Sqlstate, SQLINTEGER * NativeErrorPtr,                       SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLengthPtr);static short getFieldType(short sqltype);Environment::Environment()	: hEnv(SQL_NULL_HANDLE){	allocenv();}Environment::~Environment(){	freeenv();}/////////////////////////////////////////////////////////////////////////////bool Environment::allocenv(){	freeenv();	// Allocate the environment handle	SQLRETURN rtn = SQLAllocHandle(SQL_HANDLE_ENV,	                               SQL_NULL_HANDLE, &hEnv);	if (!SQL_SUCCEEDED(rtn))		return FALSE;	// Set the ODBC version	rtn = SQLSetEnvAttr(hEnv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);	if (!SQL_SUCCEEDED(rtn)) {		freeenv();		return FALSE;	}	return true;}/////////////////////////////////////////////////////////////////////////////bool Environment::freeenv(){	if (hEnv != SQL_NULL_HANDLE) {		SQLRETURN rtn = SQLFreeHandle(SQL_HANDLE_ENV, hEnv);		if (!SQL_SUCCEEDED(rtn))			return false;		hEnv = SQL_NULL_HANDLE;	}	return true;}Connection::Connection()	: hDbc(SQL_NULL_HANDLE),	  loginTimeout(DEFAULT_LOGIN_TIMEOUT){	allocconn();}Connection::~Connection(){	closesets();	disconnect();}/////////////////////////////////////////////////////////////////////////////bool Connection::allocconn(){	freeconn();	// Allocate the connection handle	SQLRETURN rtn = SQLAllocHandle(SQL_HANDLE_DBC,	                               E, &hDbc);	if (!SQL_SUCCEEDED(rtn))		return FALSE;	// Set login timeout	if (!setAttributes(SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)loginTimeout, 0)) {		freeconn();		return false;	}	return true;}/////////////////////////////////////////////////////////////////////////////bool Connection::freeconn(){	if (hDbc != SQL_NULL_HANDLE) {		SQLRETURN rtn = SQLFreeHandle(SQL_HANDLE_DBC, hDbc);		if (!SQL_SUCCEEDED(rtn))			return false;		hDbc = SQL_NULL_HANDLE;	}	return true;}/////////////////////////////////////////////////////////////////////////////bool Connection::setAttributes(SQLINTEGER attribute, SQLPOINTER ptr,                               SQLINTEGER len){	if (hDbc == SQL_NULL_HANDLE)		return false;	SQLRETURN rtn = SQLSetConnectAttr(hDbc, attribute, ptr, len);	return SQL_SUCCEEDED(rtn);}/////////////////////////////////////////////////////////////////////////////bool Connection::connect(LPCTSTR server, LPCTSTR uid, LPCTSTR pwd){	if (hDbc == SQL_NULL_HANDLE)		return false;	SQLRETURN rtn = SQLConnect(hDbc, (SQLCHAR *)server, SQL_NTS,	                           (SQLCHAR *)uid, SQL_NTS, (SQLCHAR *)pwd, SQL_NTS);	if (!SQL_SUCCEEDED(rtn))		throw DBException(SQL_HANDLE_DBC, hDbc);	return SQL_SUCCEEDED(rtn);}/////////////////////////////////////////////////////////////////////////////bool Connection::disconnect(){	if (hDbc == SQL_NULL_HANDLE)		return false;	SQLRETURN rtn = SQLDisconnect(hDbc);	if (!SQL_SUCCEEDED(rtn))		return FALSE;	return freeconn();}/////////////////////////////////////////////////////////////////////////////void Connection::append(Recordset *R){	_ASSERTE(R != NULL);	recordsets.push_back(R);}/////////////////////////////////////////////////////////////////////////////void Connection::remove(Recordset *R){	RecordsetVec::iterator it = recordsets.begin();	for ( ; it != recordsets.end(); it++) {		if (*it == R) {			recordsets.erase(it);			break;		}	}}/////////////////////////////////////////////////////////////////////////////void Connection::closesets(){	while (recordsets.size() != 0) {		// will remove from vector		recordsets[0]->close();	}}Recordset::Recordset(Connection *conn)	: hStmt(SQL_NULL_HANDLE),	  C(conn), columns(0), fieldinfo(NULL){	_ASSERTE(C != NULL);	C->append(this);	allocstmt();}Recordset::~Recordset(){	close();}/////////////////////////////////////////////////////////////////////////////bool Recordset::allocstmt(){	freestmt();	// Allocate the statement handle	SQLRETURN rtn = SQLAllocHandle(SQL_HANDLE_STMT,	                               *C, &hStmt);	if (!SQL_SUCCEEDED(rtn))		return FALSE;	return true;}/////////////////////////////////////////////////////////////////////////////bool Recordset::freestmt(){	if (hStmt != SQL_NULL_HANDLE) {		// free statement handle		SQLRETURN rtn = SQLFreeHandle(SQL_HANDLE_STMT, *this);		if (!SQL_SUCCEEDED(rtn))			return false;		hStmt = SQL_NULL_HANDLE;	}	return true;}/////////////////////////////////////////////////////////////////////////////bool Recordset::open(LPCTSTR sql){	_ASSERTE(sql != NULL);	if (hStmt == SQL_NULL_HANDLE)		return false;	reset();	// execute the SQL statement	SQLRETURN rtn = SQLExecDirect(*this, (SQLCHAR *)sql, SQL_NTS);	if (!SQL_SUCCEEDED(rtn))		throw DBException(SQL_HANDLE_STMT, *this);	// get the number of result columns	rtn = SQLNumResultCols(*this, &columns);	if (!SQL_SUCCEEDED(rtn))		return false;	// build field descriptions	_ASSERTE(fieldinfo == NULL);	fieldinfo = new FieldInfo[columns];	for (SQLUSMALLINT i = 1; i <= columns; i++) {		SQLSMALLINT colnamelen;		rtn = SQLDescribeCol(*this, i,		                     fieldinfo[i - 1].name, MAX_FNAME_LEN,		                     &colnamelen,		                     &fieldinfo[i - 1].type,		                     &fieldinfo[i - 1].precision,		                     &fieldinfo[i - 1].scale,		                     &fieldinfo[i - 1].nullable);		if (!SQL_SUCCEEDED(rtn))			throw DBException(SQL_HANDLE_STMT, *this);	}	return fetchRowset();}/////////////////////////////////////////////////////////////////////////////bool Recordset::fetchRowset(){	if (hStmt == SQL_NULL_HANDLE)		return false;	SQLRETURN rtn = SQLFetch(*this);	if (!SQL_SUCCEEDED(rtn))		throw DBException(SQL_HANDLE_STMT, *this);	return true;}/////////////////////////////////////////////////////////////////////////////bool Recordset::close(){	reset();	C->remove(this);	return freestmt();}void Recordset::reset(){	if (fieldinfo != NULL) {		delete [] fieldinfo;		fieldinfo = NULL;	}	columns = 0;	if (hStmt == SQL_NULL_HANDLE)		return;	// unbind, reset, and close	SQLRETURN rtn = SQLFreeStmt(*this, SQL_UNBIND);	rtn = SQLFreeStmt(*this, SQL_RESET_PARAMS);	rtn = SQLFreeStmt(*this, SQL_CLOSE);}/////////////////////////////////////////////////////////////////////////////void* Recordset::getDataBuffer(DBVariant& varValue, short fieldtype,                               int* pnLen, short sqltype, UDWORD precision){	void* pvData = NULL;	switch (fieldtype) {	case SQL_C_BIT:		pvData = &varValue.boolVal;		varValue.type = DBVariant::vt_bool;		*pnLen = sizeof(varValue.boolVal);		break;	case SQL_C_UTINYINT:		pvData = &varValue.chVal;		varValue.type = DBVariant::vt_uchar;		*pnLen = sizeof(varValue.chVal);		break;	case SQL_C_SSHORT:		pvData = &varValue.iVal;		varValue.type = DBVariant::vt_short;		*pnLen = sizeof(varValue.iVal);		break;	case SQL_C_SLONG:		pvData = &varValue.lVal;		varValue.type = DBVariant::vt_long;		*pnLen = sizeof(varValue.lVal);		break;	case SQL_C_FLOAT:		pvData = &varValue.fltVal;		varValue.type = DBVariant::vt_single;		*pnLen = sizeof(varValue.fltVal);		break;	case SQL_C_DOUBLE:		pvData = &varValue.dblVal;		varValue.type = DBVariant::vt_double;		*pnLen = sizeof(varValue.dblVal);		break;	case SQL_C_TIMESTAMP:		pvData = varValue.pdate = new TIMESTAMP_STRUCT;		varValue.type = DBVariant::vt_date;		*pnLen = sizeof(*varValue.pdate);		break;	case SQL_C_CHAR:		varValue.type = DBVariant::vt_string;		*pnLen = getTextLen(sqltype, precision);		pvData = varValue.pstring = new TCHAR[*pnLen];		break;	case SQL_C_BINARY:		if (sqltype == SQL_LONGVARBINARY) {			// pvData can't be NULL, so nLen must be at least 1			*pnLen = 1;		} else	{			// better know the length!			_ASSERTE(precision != 0);			*pnLen = precision;		}		varValue.type = DBVariant::vt_binary;		pvData = varValue.pbinary = new BYTE[*pnLen];		break;	default:		_ASSERTE(0);	}	return pvData;}/////////////////////////////////////////////////////////////////////////////int Recordset::getTextLen(short sqltype, UDWORD precision){	int len;	if (sqltype == SQL_LONGVARCHAR || sqltype == SQL_LONGVARBINARY) {		// Use a dummy length of 1 (will just get NULL terminator)		len = 1;	} else {		// better know the length		_ASSERTE(precision >= 0);		len = precision + 1;		// If converting Numeric or Decimal to text need		// room for decimal point and sign in string		if (sqltype == SQL_NUMERIC || sqltype == SQL_DECIMAL)			len += 2;	}	return len;}/////////////////////////////////////////////////////////////////////////////long Recordset::getData(short fieldindex, short fieldtype, LPVOID pvData,                        int len){	long actualsize;	// Retrieve the column in question	SQLRETURN rtn = ::SQLGetData(*this, fieldindex,	                             fieldtype, pvData, len, &actualsize);	if (!SQL_SUCCEEDED(rtn))		throw DBException(SQL_HANDLE_STMT, *this);	return actualsize;}/////////////////////////////////////////////////////////////////////////////int Recordset::getFieldIndex(LPCTSTR name) const{	for (int i = 0; i < columns; i++) {		if (_tcscmp(name, (LPCTSTR)fieldinfo[i].name) == 0)			return i;	}	return -1;	// not found}/////////////////////////////////////////////////////////////////////////////void Recordset::getFieldValue(LPCTSTR name, DBVariant & V){	V.clear();	if (columns == 0) {	// no columns		_ASSERTE(0);		return;	}	int index = getFieldIndex(name);	if (index == -1) {	// not found		throw DBException(IDS_FIELDNOTFOUND);	}	getFieldValue(index, V);}/////////////////////////////////////////////////////////////////////////////void Recordset::getFieldValue(int index, DBVariant & V){	V.clear();	if (index >= columns) {		_ASSERTE(0);		return;	}	// one based index	++index;	if (index < 1 || index > columns) { // outside range		_ASSERTE(0);		return;	}	int type = getFieldType(fieldinfo[index - 1].type);	int len = 0;	void *pvData = getDataBuffer(V, type, &len,	                             fieldinfo[index - 1].type,	                             fieldinfo[index - 1].precision);	long actual = getData(index, type, pvData, len);	if (actual == SQL_NULL_DATA) {		V.clear();	}}/////////////////////////////////////////////////////////////////////////////DBException::DBException(SQLSMALLINT HandleType, SQLHANDLE Handle){	message[0] = '\0';	state[0] = '\0';	nativeErr = 0;	SQLINTEGER count = 0;	SQLGetDiagField(HandleType, Handle, 0, SQL_DIAG_NUMBER, &count, 0, NULL);	getDiagRec(HandleType, Handle, 1 /* TODO */, state, &nativeErr,	           message, sizeof(message), NULL);}/////////////////////////////////////////////////////////////////////////////DBException::DBException(UINT ID){	state[0] = '\0';	nativeErr = 0;	_ASSERTE(hInstance != NULL);	LoadString(hInstance, ID, (LPTSTR)message, sizeof(message));}/////////////////////////////////////////////////////////////////////////////DBException::DBException(const DBException & E){	_tcscpy((LPTSTR)message, (LPCTSTR)E.message);	_tcscpy((LPTSTR)state, (LPCTSTR)E.state);	nativeErr = E.nativeErr;}/////////////////////////////////////////////////////////////////////////////DBException::~DBException(){}/////////////////////////////////////////////////////////////////////////////DBException & DBException::operator =(const DBException & E){	if (this != &E) {		_tcscpy((LPTSTR)message, (LPCTSTR)E.message);		_tcscpy((LPTSTR)state, (LPCTSTR)E.state);		nativeErr = E.nativeErr;	}	return *this;}DBVariant::DBVariant(){	// Initialize type and value	type = vt_null;}DBVariant::~DBVariant(){	clear();}//////////////////////////////////////////////////////////////////////////////void DBVariant::clear(){	if (type == vt_string)		delete []pstring;	else if (type == vt_binary)		delete []pbinary;	else if (type == vt_date)		delete pdate;	type = vt_null;}// Helper functions/////////////////////////////////////////////////////////////////////////////bool getDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle,                SQLSMALLINT RecNumber, SQLCHAR * Sqlstate, SQLINTEGER * NativeErrorPtr,                SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLengthPtr){	SQLRETURN rtn = SQLGetDiagRec(HandleType, Handle, RecNumber, Sqlstate,	                              NativeErrorPtr, MessageText, BufferLength, TextLengthPtr);	return SQL_SUCCEEDED(rtn);}/////////////////////////////////////////////////////////////////////////////short getFieldType(short sqltype){	short fieldtype = 0;	switch (sqltype) {	case SQL_BIT:		fieldtype = SQL_C_BIT;		break;	case SQL_TINYINT:		fieldtype = SQL_C_UTINYINT;		break;	case SQL_SMALLINT:		fieldtype = SQL_C_SSHORT;		break;	case SQL_INTEGER:		fieldtype = SQL_C_SLONG;		break;	case SQL_REAL:		fieldtype = SQL_C_FLOAT;		break;	case SQL_FLOAT:	case SQL_DOUBLE:		fieldtype = SQL_C_DOUBLE;		break;	case SQL_DATE:	case SQL_TIME:	case SQL_TIMESTAMP:		fieldtype = SQL_C_TIMESTAMP;		break;	case SQL_NUMERIC:	case SQL_DECIMAL:	case SQL_BIGINT:	case SQL_CHAR:	case SQL_VARCHAR:	case SQL_LONGVARCHAR:		fieldtype = SQL_C_CHAR;		break;	case SQL_BINARY:	case SQL_VARBINARY:	case SQL_LONGVARBINARY:		fieldtype = SQL_C_BINARY;		break;	default:		_ASSERTE(0);	}	return fieldtype;}